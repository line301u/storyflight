var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { valueToEstree } from "estree-util-value-to-estree";
import * as astring from "astring";
import { serializeListValue } from "./util.js";
const { generate, GENERATOR } = astring;
const customGenerator = __spreadProps(__spreadValues({}, GENERATOR), {
  Literal(node, state) {
    if (node.raw != null) {
      state.write(node.raw.replace("<\/script>", "<\\/script>"));
    } else {
      GENERATOR.Literal(node, state);
    }
  }
});
function serializeProps(value) {
  return generate(valueToEstree(value), {
    generator: customGenerator
  });
}
const HydrationDirectives = ["load", "idle", "media", "visible", "only"];
function extractDirectives(inputProps) {
  let extracted = {
    hydration: null,
    props: {}
  };
  for (const [key, value] of Object.entries(inputProps)) {
    if (key.startsWith("client:")) {
      if (!extracted.hydration) {
        extracted.hydration = {
          directive: "",
          value: "",
          componentUrl: "",
          componentExport: { value: "" }
        };
      }
      switch (key) {
        case "client:component-path": {
          extracted.hydration.componentUrl = value;
          break;
        }
        case "client:component-export": {
          extracted.hydration.componentExport.value = value;
          break;
        }
        default: {
          extracted.hydration.directive = key.split(":")[1];
          extracted.hydration.value = value;
          if (HydrationDirectives.indexOf(extracted.hydration.directive) < 0) {
            throw new Error(`Error: invalid hydration directive "${key}". Supported hydration methods: ${HydrationDirectives.map((d) => `"client:${d}"`).join(", ")}`);
          }
          if (extracted.hydration.directive === "media" && typeof extracted.hydration.value !== "string") {
            throw new Error('Error: Media query must be provided for "client:media", similar to client:media="(max-width: 600px)"');
          }
          break;
        }
      }
    } else if (key === "class:list") {
      extracted.props[key.slice(0, -5)] = serializeListValue(value);
    } else {
      extracted.props[key] = value;
    }
  }
  return extracted;
}
async function generateHydrateScript(scriptOptions, metadata) {
  const { renderer, astroId, props } = scriptOptions;
  const { hydrate, componentUrl, componentExport } = metadata;
  if (!componentExport) {
    throw new Error(`Unable to resolve a componentExport for "${metadata.displayName}"! Please open an issue.`);
  }
  let hydrationSource = "";
  if (renderer.hydrationPolyfills) {
    hydrationSource += `await Promise.all([${renderer.hydrationPolyfills.map((src) => `
  import("${src}")`).join(", ")}]);
`;
  }
  hydrationSource += renderer.source ? `const [{ ${componentExport.value}: Component }, { default: hydrate }] = await Promise.all([import("${componentUrl}"), import("${renderer.source}")]);
  return (el, children) => hydrate(el)(Component, ${serializeProps(props)}, children);
` : `await import("${componentUrl}");
  return () => {};
`;
  const hydrationScript = {
    props: { type: "module", "data-astro-component-hydration": true },
    children: `import setup from 'astro/client/${hydrate}.js';
setup("${astroId}", {${metadata.hydrateArgs ? `value: ${JSON.stringify(metadata.hydrateArgs)}` : ""}}, async () => {
  ${hydrationSource}
});
`
  };
  return hydrationScript;
}
export {
  extractDirectives,
  generateHydrateScript,
  serializeProps
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vc3JjL3J1bnRpbWUvc2VydmVyL2h5ZHJhdGlvbi50cyJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFFQSxNQUFNLEVBQUUsVUFBVSxjQUFjO0FBTWhDLE1BQU0sa0JBQXFDLGlDQUN0QyxZQURzQztBQUFBLEVBRXpDLFFBQVEsTUFBTSxPQUFPO0FBQ25CLFFBQUksS0FBSyxPQUFPLE1BQU07QUFHcEIsWUFBTSxNQUFNLEtBQUssSUFBSSxRQUFRLGNBQWE7QUFBQSxXQUNyQztBQUNMLGdCQUFVLFFBQVEsTUFBTTtBQUFBO0FBQUE7QUFBQTtBQU92Qix3QkFBd0IsT0FBWTtBQUN6QyxTQUFPLFNBQVMsY0FBYyxRQUFRO0FBQUEsSUFDcEMsV0FBVztBQUFBO0FBQUE7QUFJZixNQUFNLHNCQUFzQixDQUFDLFFBQVEsUUFBUSxTQUFTLFdBQVc7QUFjMUQsMkJBQTJCLFlBQTBEO0FBQzFGLE1BQUksWUFBNEI7QUFBQSxJQUM5QixXQUFXO0FBQUEsSUFDWCxPQUFPO0FBQUE7QUFFVCxhQUFXLENBQUMsS0FBSyxVQUFVLE9BQU8sUUFBUSxhQUFhO0FBQ3JELFFBQUksSUFBSSxXQUFXLFlBQVk7QUFDN0IsVUFBSSxDQUFDLFVBQVUsV0FBVztBQUN4QixrQkFBVSxZQUFZO0FBQUEsVUFDcEIsV0FBVztBQUFBLFVBQ1gsT0FBTztBQUFBLFVBQ1AsY0FBYztBQUFBLFVBQ2QsaUJBQWlCLEVBQUUsT0FBTztBQUFBO0FBQUE7QUFHOUIsY0FBUTtBQUFBLGFBQ0QseUJBQXlCO0FBQzVCLG9CQUFVLFVBQVUsZUFBZTtBQUNuQztBQUFBO0FBQUEsYUFFRywyQkFBMkI7QUFDOUIsb0JBQVUsVUFBVSxnQkFBZ0IsUUFBUTtBQUM1QztBQUFBO0FBQUEsaUJBRU87QUFDUCxvQkFBVSxVQUFVLFlBQVksSUFBSSxNQUFNLEtBQUs7QUFDL0Msb0JBQVUsVUFBVSxRQUFRO0FBRzVCLGNBQUksb0JBQW9CLFFBQVEsVUFBVSxVQUFVLGFBQWEsR0FBRztBQUNsRSxrQkFBTSxJQUFJLE1BQU0sdUNBQXVDLHNDQUFzQyxvQkFBb0IsSUFBSSxDQUFDLE1BQU0sV0FBVyxNQUFNLEtBQUs7QUFBQTtBQUlwSixjQUFJLFVBQVUsVUFBVSxjQUFjLFdBQVcsT0FBTyxVQUFVLFVBQVUsVUFBVSxVQUFVO0FBQzlGLGtCQUFNLElBQUksTUFBTTtBQUFBO0FBR2xCO0FBQUE7QUFBQTtBQUFBLGVBR0ssUUFBUSxjQUFjO0FBRS9CLGdCQUFVLE1BQU0sSUFBSSxNQUFNLEdBQUcsT0FBTyxtQkFBbUI7QUFBQSxXQUNsRDtBQUNMLGdCQUFVLE1BQU0sT0FBTztBQUFBO0FBQUE7QUFHM0IsU0FBTztBQUFBO0FBVVQscUNBQTRDLGVBQXFDLFVBQWlFO0FBQ2hKLFFBQU0sRUFBRSxVQUFVLFNBQVMsVUFBVTtBQUNyQyxRQUFNLEVBQUUsU0FBUyxjQUFjLG9CQUFvQjtBQUVuRCxNQUFJLENBQUMsaUJBQWlCO0FBQ3BCLFVBQU0sSUFBSSxNQUFNLDRDQUE0QyxTQUFTO0FBQUE7QUFHdkUsTUFBSSxrQkFBa0I7QUFDdEIsTUFBSSxTQUFTLG9CQUFvQjtBQUMvQix1QkFBbUIsc0JBQXNCLFNBQVMsbUJBQW1CLElBQUksQ0FBQyxRQUFnQjtBQUFBLFlBQWUsU0FBUyxLQUFLO0FBQUE7QUFBQTtBQUd6SCxxQkFBbUIsU0FBUyxTQUN4QixZQUFZLGdCQUFnQiwwRUFBMEUsMkJBQTJCLFNBQVM7QUFBQSxvREFDNUYsZUFBZTtBQUFBLElBRTdELGlCQUFpQjtBQUFBO0FBQUE7QUFJckIsUUFBTSxrQkFBa0I7QUFBQSxJQUN0QixPQUFPLEVBQUUsTUFBTSxVQUFVLGtDQUFrQztBQUFBLElBQzNELFVBQVUsbUNBQW1DO0FBQUEsU0FDeEMsY0FBYyxTQUFTLGNBQWMsVUFBVSxLQUFLLFVBQVUsU0FBUyxpQkFBaUI7QUFBQSxJQUM3RjtBQUFBO0FBQUE7QUFBQTtBQUtGLFNBQU87QUFBQTsiLAogICJuYW1lcyI6IFtdCn0K
